<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0f1014">
<title>おれらのチンチロ</title>
<style>
  :root{
    --red:#ef5350; --green:#4caf50; --blue:#42a5f5; --gold:#ffd54f;
    --bg:#0f1014; --card:#191b22; --text:#f7f7f7; --muted:#aab0bb;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:600px;margin:0 auto;padding:16px;}
  .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 8px 24px rgba(0,0,0,.35);border:1px solid #2a2e37}
  .title{display:flex;align-items:center;gap:10px;font-size:20px;font-weight:900;margin:0}
  .row{display:flex;gap:12px;align-items:center}
  .row.spread{justify-content:space-between}
  .small{font-size:12px;color:var(--muted)}
  .bigName{font-size:22px;font-weight:900}
  .pill{padding:4px 10px;border-radius:999px;font-size:12px;display:inline-flex;align-items:center;gap:6px;margin-left:6px}
  .tag-pair{background:var(--blue); color:#001a33}
  .tag-456{background:var(--green); color:#06210d}
  .tag-zoro{background:var(--red); color:#2b0000}
  .tag-pinzoro{background:var(--gold); color:#3a2b00}
  .tag-123{background:#000; color:#fff}
  .tag-shonben{background:#8e24aa; color:#fff}
  .toast{margin-top:10px;background:rgba(15,17,21,.6);border:1px solid #2a2e37;border-radius:14px;padding:16px;text-align:center;backdrop-filter: blur(6px);}
  .role{font-size:36px;font-weight:900;margin:0 0 4px 0}
  .tap{font-size:12px;color:var(--muted)}
  canvas{width:100%;height:300px;background: radial-gradient(ellipse at center, #0a0b0e 0%, #050608 70%);border-radius:16px;border:1px solid #2a2e37}
  button{background:#e53935;color:#fff;border:0;border-radius:12px;padding:14px 18px;font-weight:800;cursor:pointer}
  button.secondary{background:#2a2e37;color:#eaeaea}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=number],input[type=text]{background:#0f1115;border:1px solid #2a2e37;border-radius:10px;color:#eaeaea;padding:8px 10px}
  .rows{display:flex;flex-direction:column;border:1px solid #2a2e37;border-radius:12px;overflow:hidden}
  .rowline{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:10px 12px}
  .rowline:nth-child(odd){ background:#191c22 }
  .rowline:nth-child(even){ background:#15181d }
  .rowline .name{font-weight:800}
  .rowline .amt b{font-size:16px}
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:50}
  .modal .inner{background:var(--card);border:1px solid #2a2e37;border-radius:16px;padding:18px;max-width:360px}
  .space{height:10px}
</style>
</head>
<body>
<div class="wrap"><div id="screen"></div></div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
}

/* Audio */
const AudioFX=(function(){let c=null,g=null,ok=false;
function ctx(){ if(!c){ c=new (window.AudioContext||window.webkitAudioContext)(); g=c.createGain(); g.gain.value=0.6; g.connect(c.destination);} return c;}
function unlock(){ctx(); if(c.state==="suspended") c.resume(); ok=true;}
function click(){ if(!ok) return; const a=ctx(), o=a.createOscillator(), v=a.createGain(); o.type="triangle"; o.frequency.value=400+Math.random()*200; v.gain.value=0.0001; v.gain.exponentialRampToValueAtTime(0.18,a.currentTime+0.02); v.gain.exponentialRampToValueAtTime(0.0001,a.currentTime+0.12); o.connect(v).connect(g); o.start(); o.stop(a.currentTime+0.14); }
function deden(){ if(!ok) return; const a=ctx(); [230,180].forEach((f,i)=>{ const o=a.createOscillator(), v=a.createGain(); o.type="sine"; o.frequency.value=f; v.gain.value=0.0001; v.gain.exponentialRampToValueAtTime(0.4,a.currentTime+0.02); v.gain.exponentialRampToValueAtTime(0.0001,a.currentTime+0.16+i*0.04); o.connect(v).connect(g); o.start(); o.stop(a.currentTime+0.3); }); }
return{unlock,click,deden};})();

/* State */
let players=[{name:"A",total:0},{name:"B",total:0},{name:"C",total:0}];
let parentIndex=0; let BASE_POINT=100; let totalSets=10, currentSet=1;
let overallTotals=[]; let setHistory=[];

/* Rules */
function handFromFaces(f){
  if(f && f._shonben){ return {key:"shonben", label:"ションベン ×1", tap:"ションベン", rank:0, mult:1, tag:"shonben", mustLose:3}; }
  const sorted=f.slice().sort((a,b)=>a-b);
  const s=sorted.join("");
  if(s==="111") return {key:"pinzoro",label:"ピンゾロ ×5",tap:"ピンゾロ",rank:100,mult:5,tag:"pinzoro",mustLose:0};
  if(s==="123") return {key:"hifumi", label:"ヒフミ ×2",  tap:"ヒフミ", rank:0,  mult:-2,tag:"123",mustLose:2};
  if(s==="456") return {key:"shigoro",label:"シゴロ ×2",  tap:"シゴロ",rank:20, mult:2, tag:"456",mustLose:0};
  if(sorted[0]===sorted[1] && sorted[1]===sorted[2] && sorted[0]!==1){
    const v=sorted[0]; return {key:"zoro",label:`ゾロ目(${v}) ×3`,tap:`ゾロ${v}`,rank:30+v,mult:3,tag:"zoro",mustLose:0};
  }
  if(sorted[0]===sorted[1] && sorted[1]!==sorted[2]){
    const k=sorted[2]; return {key:"pair",label:`通常の目 (${k}) ×1`,tap:String(k),rank:10+k,mult:1,tag:"pair",mustLose:0};
  }
  if(sorted[1]===sorted[2] && sorted[0]!==sorted[1]){
    const k=sorted[0]; return {key:"pair",label:`通常の目 (${k}) ×1`,tap:String(k),rank:10+k,mult:1,tag:"pair",mustLose:0};
  }
  return {key:"menashi",label:"役なし ×1",tap:"役なし",rank:1,mult:1,tag:"menashi",mustLose:1};
}
function decideWinner(a,b){
  if(a.mustLose&&!b.mustLose) return -1;
  if(b.mustLose&&!a.mustLose) return 1;
  if(a.mustLose&&b.mustLose){ if(a.mustLose===b.mustLose) return 0; return a.mustLose>b.mustLose?-1:1; }
  if(a.rank===b.rank) return 0; return a.rank>b.rank?1:-1;
}
function settle(parent,child,base){
  const who=decideWinner(parent,child); if(who===0) return {p:0,c:0,multiShow:`${base}pt × 0`};
  const winner=(who>0?parent:child), loser=(who>0?child:parent);
  const winnerMult=Math.abs(winner.mult);
  const loserPenalty=(loser.key==="hifumi")?2:1;
  const amount=base*winnerMult*loserPenalty;
  const p=who>0?+amount:-amount;
  return {p, c:-p, multiShow:`${base}pt × ${winnerMult} × ${loserPenalty}`};
}

/* Screens */
function screenHome(){
  const n=el(`<div class="card" style="text-align:center;padding:24px 16px">
    <h2 class="title">おれらのチンチロ</h2>
    <div class="space"></div>
    <div class="row" style="gap:10px">
      <button id="start" style="flex:1">ゲームをはじめる</button>
      <button id="rules" class="secondary" style="flex:1">ルールを見る</button>
    </div>
  </div>`);
  n.querySelector("#start").onclick=()=>{ AudioFX.unlock(); screenSetup(); };
  n.querySelector("#rules").onclick=()=>{ screenRules(); };
  mount(n);
}

function screenRules(){
  const n=el(`<div class="card">
    <h3 class="title">ルール</h3>
    <div class="space"></div>
    <div class="small" style="line-height:1.7">
      ・ピンゾロ：<b>×5</b><br>
      ・ゾロ目（2～6）：<b>×3</b><br>
      ・456：<b>×2</b>（即勝）<br>
      ・123：<b>-2</b>（即負）<br>
      ・通常の目：<b>×1</b><br>
      ・ションベン：<b>×1</b>（まれな即負け）<br>
      ・各プレイヤーは<b>最大3投まで</b>。3投して役なしは<b>負け</b>。<br>
      ・掛けポイント（ベース）は<b>セット開始前に決定</b>。
    </div>
    <div class="space"></div>
    <div class="row"><button id="back" class="secondary" style="flex:1">← ホームへ戻る</button></div>
  </div>`);
  n.querySelector("#back").onclick=()=>screenHome();
  mount(n);
}

function screenSetup(){
  overallTotals=new Array(players.length).fill(0);
  setHistory=[];

  const playerRows=players.map((p,i)=>`
    <div class="row">
      <span class="small" style="width:22px">${i+1}</span>
      <input type="text" value="${p.name}" data-i="${i}" style="flex:1">
      <label class="small"><input type="radio" name="parent" ${i===parentIndex?"checked":""} data-parent="${i}"> 親</label>
      ${players.length>2?`<span class="small" data-del="${i}" style="cursor:pointer;text-decoration:underline">削除</span>`:""}
    </div>`).join("");
  const n=el(`<div class="card">
    <h3 class="title">設定</h3>
    <div class="list">${playerRows}</div>
    <div class="row" style="margin:8px 0"><span class="small" id="add" style="cursor:pointer;text-decoration:underline">＋ 追加</span></div>
    <div class="row"><label class="small" style="width:90px">ベース</label><input id="base" type="number" step="10" min="10" max="100000" value="${BASE_POINT}"><span class="small">pt</span></div>
    <div class="row"><label class="small" style="width:90px">セット数</label><input id="sets" type="number" step="1" min="1" max="200" value="${totalSets}"><span class="small">回</span></div>
    <div class="row" style="margin-top:12px"><button id="go" style="flex:1">開始</button></div>
  </div>`);
  n.querySelectorAll("input[type=text]").forEach(inp=>inp.oninput=(e)=>{players[+e.target.dataset.i].name=e.target.value;});
  n.querySelectorAll("[data-del]").forEach(a=>a.onclick=(e)=>{const i=+e.target.dataset.del; players.splice(i,1); if(parentIndex>=players.length) parentIndex=0; screenSetup();});
  n.querySelectorAll("[data-parent]").forEach(r=>r.onchange=(e)=>{parentIndex=+e.target.dataset.parent; screenSetup();});
  n.querySelector("#add").onclick=()=>{players.push({name:`Player ${players.length+1}`,total:0}); screenSetup();};
  n.querySelector("#go").onclick=()=>{
    BASE_POINT=clampInt(n.querySelector("#base").value,10,100000,BASE_POINT);
    totalSets=clampInt(n.querySelector("#sets").value,1,200,totalSets);
    currentSet=1; players.forEach(p=>p.total=0);
    screenRound();
  };
  mount(n);
}

function screenRound(){
  const order=[]; for(let i=0;i<players.length;i++){ order.push((parentIndex+i)%players.length); } // 親から1周
  const facesMap={}; const attempts={}; let curIndex=0;

  const n=el(`<div class="card">
    <div class="row spread small">
      <div>親 <b style="color:#ff6b6b">${players[parentIndex].name}</b></div>
      <div>セット <b>${currentSet}/${totalSets}</b> 回</div>
      <div>ベース <b>${BASE_POINT}pt</b></div>
    </div>
    <div class="row" style="justify-content:center;margin:6px 0 4px"><div id="turnName" class="bigName">${players[order[0]].name} の手番</div></div>
    <canvas id="cv" width="560" height="300"></canvas>
    <div id="toastArea"></div>
    <div class="row spread small"><div id="tries">試行 0/3</div><div id="status">「振る」でロール</div></div>
    <div class="row" style="margin-top:10px"><button id="roll" style="flex:1">振る</button></div>
  </div>`);
  mount(n);

  function currentPlayerIdx(){ return order[curIndex]; }
  function updateHeader(){ n.querySelector("#turnName").textContent=players[currentPlayerIdx()].name+" の手番"; }
  function updateFooter(){ n.querySelector("#tries").textContent=`試行 ${attempts[currentPlayerIdx()]||0}/3`; }
  function resetUI(){
    const area=document.getElementById("toastArea"); if(area) area.innerHTML="";
    const rb=n.querySelector("#roll"); rb.disabled=false; rb.style.display="";
    n.querySelector("#status").textContent="「振る」でロール";
  }
  updateHeader(); updateFooter(); resetUI();

  const cv=n.querySelector("#cv"), ctx=cv.getContext("2d");
  const W=cv.width, H=cv.height, cx=W/2, cy=H/2, R=115;
  const SIZE=50, RAD=SIZE*0.5*0.9;
  let dice=new Array(3).fill(0).map(()=>({x:cx,y:cy,vx:0,vy:0,ang:0,face:1,active:false}));
  let rolling=false, last=0, flick=0;
  let shonbenFlag=false;

  n.querySelector("#roll").onclick=()=>{
    if(rolling) return;
    const idx=currentPlayerIdx(); if((attempts[idx]||0)>=3) return;
    startRoll(); AudioFX.click(); n.querySelector("#roll").disabled=true;
  };

  function startRoll(){
    shonbenFlag = (Math.random() < 0.01);
    for(const d of dice){
      d.x = cx + (Math.random()*22-11);
      d.y = cy + (Math.random()*22-11);
      d.vx=Math.random()*170-85; d.vy=Math.random()*170-85; d.face=rand1to6(); d.active=true;
    }
    rolling=true;
  }
  function rand1to6(){ return 1+Math.floor(Math.random()*6); }

  requestAnimationFrame(function loop(ts){
    if(!last) last=ts;
    const dt=Math.min(32,ts-last)/1000; last=ts;
    if(rolling){
      updatePhysics(dt); separateDice();
      flick+=dt; if(flick>0.022){ for(const d of dice){ if(d.active) d.face=rand1to6(); } flick=0; }
      if(dice.every(d=>!d.active)){
        rolling=false; AudioFX.click();
        const f=dice.map(d=>d.face); if(shonbenFlag){ f._shonben=true; }
        const idx=currentPlayerIdx();
        attempts[idx]=(attempts[idx]||0)+1; updateFooter();
        const h=handFromFaces(f);
        const showPill=!(h.key==="menashi" && attempts[idx]<3);
        n.querySelector("#status").innerHTML=`出目 ${f.join("-")} ${showPill?rolePill(h):""}`;

        if(h.key!=="menashi" || attempts[idx]>=3){
          const rollBtn = n.querySelector("#roll"); if(rollBtn){ rollBtn.style.display="none"; }
          AudioFX.deden();
          const isLast=(curIndex===order.length-1);
          if(isLast){
            showRoleToast(h.tap, h.tag, ()=>{ facesMap[idx]=f; showSetResult(facesMap); });
          }else{
            const proceed=()=>{
              facesMap[idx]=f;
              curIndex++; updateHeader(); updateFooter(); resetUI();
            };
            if(h.key==="hifumi" || h.key==="shigoro"){ setTimeout(proceed, 480); }
            else{ showRoleToast(h.tap, h.tag, proceed); }
          }
        }else{
          n.querySelector("#roll").disabled=false;
        }
      }
    }
    draw(); requestAnimationFrame(loop);
  });

  function updatePhysics(dt){
    const FTR=0.96, REST=0.55;
    for(const d of dice){
      if(!d.active) continue;
      d.x+=d.vx*dt; d.y+=d.vy*dt;
      d.vx*=FTR; d.vy*=FTR;
      const dx=d.x-cx, dy=d.y-cy, dist=Math.hypot(dx,dy), rEff=(R- (RAD-2));
      if(dist>rEff){
        const nx=dx/dist, ny=dy/dist;
        d.x=cx+nx*rEff; d.y=cy+ny*rEff;
        const vn=d.vx*nx+d.vy*ny;
        d.vx-=(1+REST)*vn*nx; d.vy-=(1+REST)*vn*ny;
      }
      if(Math.hypot(d.vx,d.vy)<10){ d.vx=d.vy=0; d.active=false; }
    }
  }
  function separateDice(){
    const minDist=RAD*2+12;
    for(let k=0;k<6;k++){
      for(let i=0;i<dice.length;i++){
        for(let j=i+1;j<dice.length;j++){
          const a=dice[i], b=dice[j], dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy);
          if(dist>0 && dist<minDist){
            const nx=dx/dist, ny=dy/dist, ov=(minDist-dist)/2;
            a.x-=nx*ov; a.y-=ny*ov; b.x+=nx*ov; b.y+=ny*ov;
          }
        }
      }
    }
  }
  function draw(){
    const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
    const W=cv.width, H=cv.height, cx=W/2, cy=H/2, R=115;
    ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,R+10,0,Math.PI*2);
    const grd=ctx.createRadialGradient(cx,cy,10,cx,cy,R+10); grd.addColorStop(0,"#0b0c0f"); grd.addColorStop(1,"#06070a");
    ctx.fillStyle=grd; ctx.fill(); ctx.strokeStyle="#2a2e37"; ctx.lineWidth=2; ctx.stroke(); ctx.restore();
    for(const d of dice){
      ctx.save(); ctx.translate(d.x,d.y);
      drawDie(ctx,-50/2,-50/2,50,d.face); ctx.restore();
    }
  }
  function drawDie(ctx,x,y,size,face){
    ctx.fillStyle="#fff"; const r=10; roundRect(ctx,x,y,size,size,r); ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.15)"; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle=(face===1)?"#d32f2f":"#111";
    const dot=(dx,dy)=>{ ctx.beginPath(); ctx.arc(x+dx,y+dy,size*0.08,0,Math.PI*2); ctx.fill(); };
    const s=size,c=s/2,d=s*0.28;
    switch(face){
      case 1: dot(c,c); break;
      case 2: dot(c-d,c-d); dot(c+d,c+d); break;
      case 3: dot(c-d,c-d); dot(c,c); dot(c+d,c+d); break;
      case 4: dot(c-d,c-d); dot(c+d,c-d); dot(c-d,c+d); dot(c+d,c+d); break;
      case 5: dot(c-d,c-d); dot(c+d,c-d); dot(c,c); dot(c-d,c+d); dot(c+d,c+d); break;
      case 6: dot(c-d,c-d); dot(c,c-d); dot(c+d,c-d); dot(c-d,c+d); dot(c,c+d); dot(c+d,c+d); break;
    }
  }
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function rolePill(h){
    const cls=h.key==="pinzoro"?"tag-pinzoro": h.key==="zoro"?"tag-zoro": h.key==="shigoro"?"tag-456": h.key==="pair"?"tag-pair": h.key==="hifumi"?"tag-123": h.key==="shonben"?"tag-shonben":"tag-menashi";
    return `<span class="pill ${cls}">${h.label}</span>`;
  }
  function showRoleToast(text, tag, onTap){
    const area=document.getElementById("toastArea"); area.innerHTML="";
    const div=document.createElement("div"); div.className="toast"; div.style=roleStyle(tag);
    div.innerHTML=`<div class="role">${text}</div><div class="tap">タップで次へ</div>`;
    div.onclick=()=>{ div.remove(); onTap&&onTap(); };
    area.appendChild(div);
  }
  function roleStyle(tag){
    switch(tag){
      case "pinzoro": return "color:#3a2b00; background: rgba(255,213,79,.15)";
      case "zoro": return "color: var(--red); background: rgba(239,83,80,.12)";
      case "456": return "color: var(--green); background: rgba(76,175,80,.12)";
      case "pair": return "color: var(--blue); background: rgba(66,165,245,.12)";
      case "123": return "color:#fff; background: rgba(0,0,0,.3)";
      case "shonben": return "color:#fff; background: rgba(142,36,170,.25)";
      default: return "color:#c3c9d1; background: rgba(42,46,55,.2)";
    }
  }

  function showSetResult(faces){
    const parentH=handFromFaces(faces[parentIndex]||[1,1,1]);
    let totals=Array(players.length).fill(0);
    const perRows=players.map((p,i)=>{
      if(i===parentIndex) return "";
      const h=handFromFaces(faces[i]||[1,1,1]);
      const r=settle(parentH,h,BASE_POINT);
      totals[parentIndex]+=r.p; totals[i]+=r.c;
      const cls=h.key==="pinzoro"?"tag-pinzoro": h.key==="zoro"?"tag-zoro": h.key==="shigoro"?"tag-456": h.key==="pair"?"tag-pair": h.key==="hifumi"?"tag-123": h.key==="shonben"?"tag-shonben":"tag-menashi";
      const sign=r.c>=0?"+":"";
      return `<div class="rowline">
        <div class="name">${p.name} <span class="pill ${cls}" style="margin-left:6px">${h.label}</span></div>
        <div class="amt">${sign}${r.c} <span class="small">（${r.multiShow}）</span></div>
      </div>`;
    }).join("");

    const totalsRow=players.map((p,i)=>`<div class="rowline"><div class="name">${p.name}</div><div class="amt"><b>${totals[i]>=0? "+"+totals[i]: totals[i]}</b></div></div>`).join("");

    if(overallTotals.length!==players.length){ overallTotals=new Array(players.length).fill(0); }
    for(let i=0;i<players.length;i++){ overallTotals[i]+=totals[i]; }
    setHistory.push({set: currentSet, totals: totals});

    const pv=el(`<div class="card">
      <h3 class="title">${currentSet}セット目 結果</h3>
      <div class="small">親 <b style="color:#ff6b6b">${players[parentIndex].name}</b> ／ ベース <b>${BASE_POINT}pt</b> ／ 親の役：${parentH.label}</div>
      <div class="space"></div>
      <div class="rows">${perRows}</div>
      <div class="space"></div>
      <div class="rows">${totalsRow}</div>
      <div class="row" style="margin-top:12px">
        <button id="next" style="flex:1">${currentSet<totalSets?"次へ":"全セット合計"}</button>
      </div>
    </div>`);
    pv.querySelector("#next").onclick=()=>{
      if(currentSet<totalSets){
        currentSet++; parentIndex = (parentIndex + 1) % players.length;
        players.forEach(p=>p.total=0);
        screenRound();
      }else{
        simpleConfirm("全セット合計へ進みます。よろしいですか？", ()=> showAllTotals());
      }
    };
    mount(pv);
  }
}

function showAllTotals(){
  const rows=players.map((p,i)=>{
    const v=overallTotals[i]||0;
    const sign=v>=0?"+":"";
    return `<div class="rowline"><div class="name">${p.name}</div><div class="amt"><b>${sign}${v}pt</b></div></div>`;
  }).join("");

  const details = setHistory.map(h=>{
    const line = players.map((p,i)=>{
      const v=h.totals[i]||0; const s=v>=0?"+":"";
      return `${p.name}:${s}${v}pt`;
    }).join(" / ");
    return `<div class="small">第${h.set}セット：${line}</div>`;
  }).join("");

  const n=el(`<div class="card">
    <h3 class="title">全セット合計</h3>
    <div class="rows" style="margin-top:8px">${rows}</div>
    <div class="space"></div>
    <div>${details}</div>
    <div class="row" style="margin-top:12px">
      <button id="finish" style="flex:1">終了</button>
    </div>
  </div>`);
  n.querySelector("#finish").onclick=()=>{
    showFinalSetPopup("全セット終了");
  };
  mount(n);
}

/* Final popup */
function showFinalSetPopup(title){
  const modal=document.createElement("div"); modal.className="modal";
  modal.innerHTML=`<div class="inner">
    <h3 style="margin:0 0 8px 0">${title}</h3>
    <div class="small" style="margin-bottom:12px">終了しますか？</div>
    <div class="row" style="justify-content:flex-end; gap:8px">
      <button id="cancel">キャンセル</button>
      <button id="ok">OK</button>
    </div>
  </div>`;
  modal.querySelector("#cancel").onclick=()=>modal.remove();
  modal.querySelector("#ok").onclick=()=>{ modal.remove(); screenHome(); };
  document.body.appendChild(modal);
}

/* Utils */
function el(h){ const d=document.createElement("div"); d.innerHTML=h.trim(); return d.firstElementChild; }
function clampInt(v,min,max,fallback){ const n=Number(v); if(!Number.isFinite(n)) return fallback; return Math.max(min,Math.min(max,Math.round(n))); }
function mount(n){ const root=document.getElementById("screen"); root.innerHTML=""; root.appendChild(n); }
function simpleConfirm(msg, onYes){
  const modal=document.createElement("div"); modal.className="modal";
  modal.innerHTML=`<div class="inner"><div style="margin-bottom:10px">${msg}</div><div class="row" style="justify-content:flex-end;gap:8px"><button id="cancel">キャンセル</button><button id="ok">OK</button></div></div>`;
  modal.querySelector("#cancel").onclick=()=>modal.remove();
  modal.querySelector("#ok").onclick=()=>{ modal.remove(); onYes&&onYes(); };
  document.body.appendChild(modal);
}

screenHome();
</script>
</body>
</html>
